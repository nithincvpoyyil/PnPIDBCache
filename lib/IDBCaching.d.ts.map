{"version":3,"sources":["../src/IDBCaching.ts"],"names":[],"mappings":"AAAA,OAAO,EAAsB,SAAS,EAAwB,MAAM,gBAAgB,CAAC;AACrF,OAAO,EAAwB,YAAY,EAAE,MAAM,WAAW,CAAC;AAC/D,OAAO,EAAE,kBAAkB,EAAqB,MAAM,cAAc,CAAC;AAIrE,oBAAY,eAAe,GAAG,CAAC,GAAG,EAAE,MAAM,KAAK,MAAM,CAAC;AACtD,oBAAY,eAAe,GAAG,CAAC,GAAG,EAAE,MAAM,KAAK,IAAI,CAAC;AAEpD,MAAM,WAAW,aAAa;IAC5B,UAAU,CAAC,EAAE,eAAe,CAAC;IAC7B,UAAU,CAAC,EAAE,eAAe,CAAC;IAC7B,SAAS,CAAC,EAAE,kBAAkB,CAAC;CAChC;AAED,wBAAgB,UAAU,CAAC,KAAK,CAAC,EAAE,aAAa,GAAG,YAAY,CAAC,SAAS,CAAC,CAgDzE","file":"IDBCaching.d.ts","sourcesContent":["import { IQueryableInternal, Queryable, QueryablePreObserver } from '@pnp/queryable';\r\nimport { getHashCode, dateAdd, TimelinePipe } from '@pnp/core';\r\nimport { ICustomStoreParams, IDBStorageWrapper } from './IDBStorage';\r\n\r\nlet idbStorageWrapper: IDBStorageWrapper;\r\n\r\nexport type CacheKeyFactory = (url: string) => string;\r\nexport type CacheExpireFunc = (url: string) => Date;\r\n\r\nexport interface ICachingProps {\r\n  keyFactory?: CacheKeyFactory;\r\n  expireFunc?: CacheExpireFunc;\r\n  idbParams?: ICustomStoreParams;\r\n}\r\n\r\nexport function IDBCaching(props?: ICachingProps): TimelinePipe<Queryable> {\r\n  const { keyFactory, expireFunc, idbParams } = {\r\n    keyFactory: (url: string) => getHashCode(url.toLowerCase()).toString(),\r\n    expireFunc: () => dateAdd(new Date(), 'minute',1),\r\n    ...props,\r\n  };\r\n\r\n  const idbCacheObserver: QueryablePreObserver = async function (\r\n    this: IQueryableInternal,\r\n    url: string,\r\n    init: RequestInit,\r\n    result: any,\r\n  ) {\r\n    let method = init.method || '';\r\n    //@ts-ignore\r\n    let cacheHeader = init.headers && init?.headers['X-PnP-CacheAlways'] ? init?.headers['X-PnP-CacheAlways'] : '';\r\n\r\n    // only cache get requested data or where the CacheAlways header is present (allows caching of POST requests)\r\n    if (/get/i.test(method) || cacheHeader) {\r\n      //@ts-ignore\r\n      const key = init?.headers['X-PnP-CacheKey'] ? init.headers['X-PnP-CacheKey'] : keyFactory(url.toString());\r\n\r\n      if (!idbStorageWrapper) {\r\n        idbStorageWrapper = new IDBStorageWrapper(idbParams);\r\n      }\r\n\r\n      let indexdbData = await idbStorageWrapper.get(key);\r\n\r\n      if (indexdbData == null) {\r\n        //  falling back to network to update cache\r\n\r\n        this.on.post(async function (url: URL, result1: any) {\r\n          let expiryDate = expireFunc(url.toString()) || new Date();\r\n          await idbStorageWrapper.put(key, result1, expiryDate);\r\n          return [url, result1];\r\n        });\r\n      } else {\r\n        result = indexdbData;\r\n      }\r\n    }\r\n\r\n    return Promise.resolve([url, init, result]);\r\n  };\r\n\r\n  return (instance: Queryable) => {\r\n    instance.on.pre(idbCacheObserver);\r\n    return instance;\r\n  };\r\n}\r\n"]}