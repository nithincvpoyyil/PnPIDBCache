{"version":3,"sources":["../src/IDBStorage.ts"],"names":[],"mappings":"AAEA,MAAM,WAAW,kBAAkB;IACjC,MAAM,EAAE,MAAM,CAAC;IACf,SAAS,EAAE,MAAM,CAAC;CACnB;AAED,MAAM,WAAW,SAAS,CAAC,CAAC,GAAG,GAAG;IAChC,MAAM,EAAE,IAAI,CAAC;IACb,cAAc,EAAE,MAAM,CAAC;IACvB,IAAI,EAAE,CAAC,CAAC;CACT;AAED,eAAO,MAAM,eAAe,sBAAsB,CAAC;AACnD,eAAO,MAAM,kBAAkB,+BAA+B,CAAC;AAE/D,qBAAa,UAAU,CAAC,CAAC,GAAG,GAAG;IAC7B,OAAO,CAAC,SAAS,CAAuB;IACxC,OAAO,CAAC,gBAAgB,CAAkB;gBAE9B,iBAAiB,CAAC,EAAE,kBAAkB;IAWlD,IAAW,cAAc,IAAI,OAAO,CAEnC;IAED,IAAW,MAAM,IAAI,OAAO,CAAC,MAAM,CAAC,CAKnC;IAEM,KAAK,IAAI,OAAO,CAAC,IAAI,CAAC;IAItB,OAAO,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAAC,CAAC,GAAG,SAAS,CAAC;IAI5C,UAAU,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC;IAItC,OAAO,CAAC,GAAG,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,GAAG,OAAO,CAAC,IAAI,CAAC;IAI9C,UAAU,IAAI,OAAO,CAAC,CAAC,WAAW,EAAE,GAAG,CAAC,EAAE,CAAC;IAI3C,IAAI,IAAI,OAAO;CAGvB;AAED,qBAAa,iBAAiB;IAGhB,OAAO,CAAC,iBAAiB,CAAC;IAFtC,OAAO,CAAC,UAAU,CAAa;gBAEX,iBAAiB,CAAC,gCAAoB;IAO1D;;;;;OAKG;IACI,GAAG,CAAC,CAAC,GAAG,GAAG,EAAE,GAAG,EAAE,MAAM,GAAG,OAAO,CAAC,CAAC,GAAG,IAAI,GAAG,SAAS,CAAC;IA8B/D;;;;;;OAMG;IACU,GAAG,CAAC,GAAG,EAAE,MAAM,EAAE,CAAC,EAAE,GAAG,EAAE,MAAM,EAAE,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;IAYlE;;;;OAIG;IACI,MAAM,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC;IAOzC;;OAEG;IACI,aAAa,IAAI,OAAO,CAAC,IAAI,CAAC;CAmBtC","file":"IDBStorage.d.ts","sourcesContent":["import { set, get, clear, createStore, UseStore, keys, del, entries } from 'idb-keyval';\r\n\r\nexport interface ICustomStoreParams {\r\n  dbName: string;\r\n  storeName: string;\r\n}\r\n\r\nexport interface IIDBValue<T = any> {\r\n  expiry: Date;\r\n  indexedDBCache: number;\r\n  data: T;\r\n}\r\n\r\nexport const DEFAULT_DB_NAME = 'IDBStorgeDBForPnP';\r\nexport const DEFAULT_STORE_NAME = 'IDBStorgeDBStoreNameForPnP';\r\n\r\nexport class IDBStorage<T = any> {\r\n  private _idbStore: UseStore | undefined;\r\n  private isIndexedDBError: boolean = false;\r\n\r\n  constructor(customStoreparams?: ICustomStoreParams) {\r\n    if (!window.indexedDB) {\r\n      this.isIndexedDBError = true;\r\n    }\r\n    if (customStoreparams && customStoreparams.dbName && customStoreparams.storeName) {\r\n      this._idbStore = createStore(customStoreparams.dbName, customStoreparams.storeName);\r\n    } else {\r\n      this._idbStore = createStore(DEFAULT_DB_NAME, DEFAULT_STORE_NAME);\r\n    }\r\n  }\r\n\r\n  public get indexedDBError(): boolean {\r\n    return this.isIndexedDBError;\r\n  }\r\n\r\n  public get length(): Promise<number> {\r\n    return (async () => {\r\n      let keyList = await keys(this._idbStore);\r\n      return keyList.length;\r\n    })();\r\n  }\r\n\r\n  public clear(): Promise<void> {\r\n    return clear(this._idbStore);\r\n  }\r\n\r\n  public getItem(key: string): Promise<T | undefined> {\r\n    return get(key, this._idbStore);\r\n  }\r\n\r\n  public removeItem(key: string): Promise<void> {\r\n    return del(key, this._idbStore);\r\n  }\r\n\r\n  public setItem(key: string, data: any): Promise<void> {\r\n    return set(key, data, this._idbStore);\r\n  }\r\n\r\n  public getEntries(): Promise<[IDBValidKey, any][]> {\r\n    return entries(this._idbStore);\r\n  }\r\n\r\n  public test(): boolean {\r\n    return !!window.indexedDB;\r\n  }\r\n}\r\n\r\nexport class IDBStorageWrapper {\r\n  private idbStorage: IDBStorage;\r\n\r\n  constructor(private customStoreparams?: ICustomStoreParams) {\r\n    if (!customStoreparams || !customStoreparams.dbName || !customStoreparams.storeName) {\r\n      this.customStoreparams = { dbName: DEFAULT_DB_NAME, storeName: DEFAULT_STORE_NAME };\r\n    }\r\n    this.idbStorage = new IDBStorage(this.customStoreparams);\r\n  }\r\n\r\n  /**\r\n   * Get value from underlying storage by key\r\n   *\r\n   * @param key\r\n   * @returns\r\n   */\r\n  public get<T = any>(key: string): Promise<T | null | undefined> {\r\n    return new Promise<T | null | undefined>((resolve, reject) => {\r\n      if (this.idbStorage.indexedDBError) {\r\n        resolve(null);\r\n      }\r\n\r\n      this.idbStorage\r\n        .getItem(key)\r\n        .then(async (idbData: IIDBValue) => {\r\n          if (idbData && idbData.indexedDBCache) {\r\n            let isExpired = idbData.expiry <= new Date();\r\n            if (isExpired) {\r\n              this.delete(key);\r\n              return null;\r\n            } else {\r\n              return idbData.data as T;\r\n            }\r\n          }\r\n        })\r\n        .then(\r\n          (data: T | null | undefined) => {\r\n            resolve(data);\r\n          },\r\n          () => {\r\n            resolve(null);\r\n          },\r\n        );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Adds a value to the underlying storage\r\n   *\r\n   * @param key The key to use when storing the provided value\r\n   * @param o The value to store\r\n   * @param expiry adds expiry date\r\n   */\r\n  public async put(key: string, o: any, expiry: Date): Promise<void> {\r\n    if (this.idbStorage.indexedDBError) {\r\n      return Promise.resolve();\r\n    }\r\n    try {\r\n      let toIDBStore: IIDBValue = { expiry, data: o, indexedDBCache: 1 };\r\n      return this.idbStorage.setItem(key, toIDBStore);\r\n    } catch {\r\n      return Promise.reject();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deletes a value from the underlying storage\r\n   *\r\n   * @param key The key of the pair we want to remove from storage\r\n   */\r\n  public delete(key: string): Promise<void> {\r\n    if (this.idbStorage.indexedDBError) {\r\n      return Promise.resolve();\r\n    }\r\n    return this.idbStorage.removeItem(key);\r\n  }\r\n\r\n  /**\r\n   * Deletes any expired items\r\n   */\r\n  public deleteExpired(): Promise<void> {\r\n    if (this.idbStorage.indexedDBError) {\r\n      return Promise.resolve();\r\n    }\r\n    return new Promise<void>(async (resolve, reject) => {\r\n      try {\r\n        this.idbStorage.clear().then(\r\n          () => {\r\n            resolve();\r\n          },\r\n          () => {\r\n            reject();\r\n          },\r\n        );\r\n      } catch (e) {\r\n        reject(e);\r\n      }\r\n    });\r\n  }\r\n}\r\n"]}