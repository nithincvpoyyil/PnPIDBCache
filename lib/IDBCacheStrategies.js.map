{"version":3,"file":"IDBCacheStrategies.js","names":["__awaiter","this","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","n","v","op","TypeError","call","pop","length","push","Object","defineProperty","exports","cacheOnly","cacheFirst","staleWhileRevalidateWithExpiry","staleWhileRevalidate","indexedDBStorageInstance","IDBStorage_1","require","key","p","dbParams","_a","dbName","storeName","IDBStorage","indexedDBError","getItem","u","setItem","expiry","expiryDate","isExpired","data","Date","getTime","indexedDBCache","response","undefined"],"sources":["IDBCacheStrategies.js"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.cacheOnly = exports.cacheFirst = exports.staleWhileRevalidateWithExpiry = exports.staleWhileRevalidate = void 0;\nvar IDBStorage_1 = require(\"./IDBStorage\");\nvar indexedDBStorageInstance;\n/**\n * Stale-while-revalidate caching strategy without expiration\n *\n *\n * @param key - cache key value for the network request or item\n * @param p - request Promise object to fulfill network request\n * @param dbParams - custom indexed db store parameters. If this value is not passed, default values will be selected\n * @returns  Promise<T>\n *\n * Check link for more information: https://developer.chrome.com/docs/workbox/caching-strategies-overview/#stale-while-revalidate\n *\n * @example\n * const reponse = await staleWhileRevalidate(\"key-1\", sp.web.select(\"Title\", \"Description\").get(),{dbName:'myAppcacheDB',storeName:'homePage'});\n *\n */\nfunction staleWhileRevalidate(key, p, dbParams) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value, result;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!dbParams) {\n                        dbParams = { dbName: '', storeName: '' };\n                    }\n                    if (!indexedDBStorageInstance) {\n                        indexedDBStorageInstance = new IDBStorage_1.IDBStorage(dbParams);\n                    }\n                    if (!!indexedDBStorageInstance.indexedDBError) return [3 /*break*/, 2];\n                    return [4 /*yield*/, indexedDBStorageInstance.getItem(key)];\n                case 1:\n                    value = _a.sent();\n                    if (value) {\n                        // update cache once we have a result\n                        p.then(function (u) {\n                            return indexedDBStorageInstance.setItem(key, u);\n                        });\n                        // response return from cache\n                        return [2 /*return*/, value];\n                    }\n                    _a.label = 2;\n                case 2: return [4 /*yield*/, p];\n                case 3:\n                    result = _a.sent();\n                    // Set Cache\n                    if (!indexedDBStorageInstance.indexedDBError) {\n                        indexedDBStorageInstance.setItem(key, result);\n                    }\n                    // Return from Promise\n                    return [2 /*return*/, result];\n            }\n        });\n    });\n}\nexports.staleWhileRevalidate = staleWhileRevalidate;\n/**\n * Stale-while-revalidate caching strategy with expiration\n *\n *\n * @param key - cache key value for the network request or item\n * @param p - request Promise object to fulfill network request\n * @param expiry - Date object for the cache expiration. If this value is  not passed, default value will be taken current time + 1 hour\n * @param dbParams - optional custom indexed db store parameters. If this value is not passed, default values will be selected\n * @returns  Promise<T>\n *\n * Check link for more information: https://developer.chrome.com/docs/workbox/caching-strategies-overview/#stale-while-revalidate\n *\n * @example\n * let expiry = new Date(new Date().getTme()+980000);\n * let request = sp.web.select(\"Title\", \"Description\").get()\n * const reponse = await staleWhileRevalidateWithExpiry(\"key-1\", request, expiry,{dbName:'myAppcacheDB',storeName:'homePage'});\n *\n */\nfunction staleWhileRevalidateWithExpiry(key, p, expiry, dbParams) {\n    return __awaiter(this, void 0, void 0, function () {\n        var expiryDate, value, isExpired, result, data;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!indexedDBStorageInstance) {\n                        indexedDBStorageInstance = new IDBStorage_1.IDBStorage(dbParams);\n                    }\n                    if (!dbParams) {\n                        dbParams = { dbName: '', storeName: '' };\n                    }\n                    expiryDate = expiry && typeof Date === 'object' ? expiry : new Date(new Date().getTime() + 1000 * 60 * 10);\n                    if (!!indexedDBStorageInstance.indexedDBError) return [3 /*break*/, 2];\n                    return [4 /*yield*/, indexedDBStorageInstance.getItem(key)];\n                case 1:\n                    value = _a.sent();\n                    isExpired = value.expiry <= new Date();\n                    if (value && value.indexedDBCache && !isExpired) {\n                        // update cache once we have a result\n                        p.then(function (u) {\n                            var response = { expiry: expiryDate, data: u, indexedDBCache: 1 };\n                            return indexedDBStorageInstance.setItem(key, response);\n                        });\n                        // response return from cache\n                        return [2 /*return*/, value.data];\n                    }\n                    _a.label = 2;\n                case 2: return [4 /*yield*/, p];\n                case 3:\n                    result = _a.sent();\n                    // Set Cache\n                    if (!indexedDBStorageInstance.indexedDBError) {\n                        data = { expiry: expiryDate, data: result, indexedDBCache: 1 };\n                        indexedDBStorageInstance.setItem(key, data);\n                    }\n                    // return from promise\n                    return [2 /*return*/, result];\n            }\n        });\n    });\n}\nexports.staleWhileRevalidateWithExpiry = staleWhileRevalidateWithExpiry;\n/**\n *\n * cache-first caching strategy with expiration\n *\n * @param key - cache key value for the network request or item\n * @param p - request Promise object to fulfill network request\n * @param expiry - Date object for the cache expiration. If this value is  not passed, default value will be taken current time + 1 hour\n * @param dbParams - optional custom indexed db store parameters. If this value is not passed, default values will be selected\n * @returns  Promise<T>\n *\n * Check link for more information: https://developer.chrome.com/docs/workbox/caching-strategies-overview/#cache-first-falling-back-to-network\n *\n * @example\n * let expiry = new Date(new Date().getTme()+980000);\n * let request = sp.web.select(\"Title\", \"Description\").get()\n * const reponse = await cacheFirst(\"key-1\", request, expiry,{dbName:'myAppcacheDB',storeName:'homePage'});\n *\n */\nfunction cacheFirst(key, p, expiry, dbParams) {\n    return __awaiter(this, void 0, void 0, function () {\n        var expiryDate, value, isExpired, result, data;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!dbParams) {\n                        dbParams = { dbName: '', storeName: '' };\n                    }\n                    if (!indexedDBStorageInstance) {\n                        indexedDBStorageInstance = new IDBStorage_1.IDBStorage(dbParams);\n                    }\n                    expiryDate = expiry && typeof Date === 'object' ? expiry : new Date(new Date().getTime() + 1000 * 60 * 10);\n                    if (!!indexedDBStorageInstance.indexedDBError) return [3 /*break*/, 2];\n                    return [4 /*yield*/, indexedDBStorageInstance.getItem(key)];\n                case 1:\n                    value = _a.sent();\n                    isExpired = value.expiry <= new Date();\n                    // Return from Cache\n                    if (value && value.indexedDBCache && !isExpired) {\n                        return [2 /*return*/, value.data];\n                    }\n                    _a.label = 2;\n                case 2: return [4 /*yield*/, p];\n                case 3:\n                    result = _a.sent();\n                    // Set Cache\n                    if (!indexedDBStorageInstance.indexedDBError) {\n                        data = { expiry: expiryDate, data: result, indexedDBCache: 1 };\n                        indexedDBStorageInstance.setItem(key, data);\n                    }\n                    // Return from Promise\n                    return [2 /*return*/, result];\n            }\n        });\n    });\n}\nexports.cacheFirst = cacheFirst;\n/**\n *\n * cache-only caching strategy with expiration\n *\n *\n * @param key - cache key value for the network request or item\n * @param dbParams - optional custom indexed db store parameters. If this value is not passed, default values will be selected\n * @returns  Promise<T | undefined>\n *\n * Check link for more information: https://developer.chrome.com/docs/workbox/caching-strategies-overview/#cache-only\n *\n * @example\n *\n * const reponse = await cacheOnly(\"key-1\", {dbName:'myAppcacheDB',storeName:'homePage'});\n */\nfunction cacheOnly(key, dbParams) {\n    return __awaiter(this, void 0, void 0, function () {\n        var value, isExpired;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!dbParams) {\n                        dbParams = { dbName: '', storeName: '' };\n                    }\n                    if (!indexedDBStorageInstance) {\n                        indexedDBStorageInstance = new IDBStorage_1.IDBStorage(dbParams);\n                    }\n                    if (!!indexedDBStorageInstance.indexedDBError) return [3 /*break*/, 2];\n                    return [4 /*yield*/, indexedDBStorageInstance.getItem(key)];\n                case 1:\n                    value = _a.sent();\n                    isExpired = value.expiry <= new Date();\n                    // Return from Cache\n                    if (value && value.indexedDBCache && !isExpired) {\n                        return [2 /*return*/, value.data];\n                    }\n                    else {\n                        return [2 /*return*/, undefined];\n                    }\n                    _a.label = 2;\n                case 2: return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.cacheOnly = cacheOnly;\n"]}